# -*- coding: utf-8 -*-
"""pyhtonproj-ainotemaker.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PWbv0Zf0Sw-z5vdV_yEO1goDqhesH861
"""

# you can get your own key from Google AI studio for gemini

# !pip install requests google-generativeai reportlab PyPDF2 google-api-python-client duckduckgo-search --quiet


import random
import re
import requests
import google.generativeai as genai
from googleapiclient.discovery import build

import sys
import os

from reportlab.lib.pagesizes import A4
from reportlab.platypus import Paragraph, SimpleDocTemplate, Spacer, PageBreak
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib.units import inch
from PyPDF2 import PdfMerger

token = "";
api_URL = "";
gemini_token = ""
google_search_api_key = ""
google_search_cx = ""
search_result_count = 5
isDebug = True
addImages = False
imagesLimit = 3
getInstantProgressPDF = False
recommendTopics = False
getQuestions = False
getNotes = False
getFlashCards = True
startIndex = 0

# instant defaults on my git file : https://github.com/JadejaPriyanshiba/python-projects/blob/main/ai_note_maker/config/instant_default.py

# subject = "AI ML And biotechnology"
# title = "AI And LLM Approach to prevent Type 1 diabetes (T1D) and myasthenia gravis"
# length = "300 lines"
# maturity = "for a PDF student researching about these diseases exploring these finding hidden patterns and eager to know more"

# extraNotes = "make it more knowledgeable and in depth that can help a researching student about this, you acn diacuss the relation, hidden and main detals, possiblity of realtions or some facts, everything important that is required for being best"

# complexity = "in depth research and knowledge"

# wantGemini = True

# preDefineTopics = """Type 1 Diabetes (T1D) Pathogenesis (brief context for modeling),,
# Myasthenia Gravis (MG) Pathogenesis (brief context for modeling),,
# Genomic, Proteomic, and Metabolomic Biomarker Discovery in T1D and MG,,
# Immunological Phenotyping and Immune Cell Trajectories,,
# Electronic Health Record (EHR) Data Mining for T1D and MG,,
# Multi-omics Data Integration Techniques,,
# Identifying Hidden Patterns in Complex Autoimmune Data,,
# Machine Learning (ML) Fundamentals for Healthcare Applications,,
# Deep Learning Architectures for Medical Data,,
# Large Language Model (LLM) Capabilities and Limitations in Biomedical Research,,
# NLP for Literature Mining and Hypothesis Generation in T1D and MG,,
# Predictive Modeling for Presymptomatic T1D and MG,,
# AI-driven Early Warning Systems for T1D and MG,,
# Personalized Prevention Strategies using AI/ML,,
# Explainable AI (XAI) for Transparent Autoimmune Prediction,,"""

subject = "Computer Architecture And Organization"
title = "Input-Output Organization"
length = "100 lines"
maturity = "for computer engineering diploma student"
extraNotes = "make it more knowledgeable and in depth, make statements point-wise, short, and to the point were needed"
complexity = "in depth research and knowledge"
wantGemini = True
preDefineTopics = """Input-Output Interface,,
Programmed I/O and Interrupt initiated I/O,,
CPU-IOP communication,,
Quick Summary"""


def moveElement(array, fromIndex, toIndex):
    if( not (isinstance(array, list) and isinstance(fromIndex, int) and isinstance(toIndex, int))):
        print("invalid data types ", type(array), type(fromIndex), type(toIndex))
        return
    elif(fromIndex<0 or fromIndex>=len(array) or toIndex>=len(array) or toIndex<0 or toIndex==fromIndex):
        print("Invalid ranges: ", fromIndex, toIndex, len(array))
        return
    item = array.pop(fromIndex)
    array.insert(toIndex, item)

def callAPIModel(prompt):

    headers = {"Authorization": f"Bearer {token}"}

    payload = {
        "inputs" : prompt
    }
    response = requests.post(apiURL, headers=headers, json=payload)
    if(response.status_code!=200):
        raise Exception("something went wrong couldn't load response")
    print(str(response))
    return response.json()[0]['generated_text']

def connectGemini2Flash(prompt, model_name='gemini-2.5-flash'):
    # Step 1: Configure with your API key1
    apiKey = gemini_token.strip()
    genai.configure(api_key=apiKey)  # Replace with your key

    try:
        model = genai.GenerativeModel(model_name)
        response = model.generate_content(prompt)
        print(response.text)
        return response.text
    except Exception as e:
        print("Error occurred:", e)

# validate topics given, modify list accordingly
class ValidateTopics:
    topicsByAI = []

    instructions = """ ~~~~ INSTRUCTIONS ~~~~

~ Enter 'ok' if the list seems perfect,
~ Enter 'instruct' to get instructions again,
~ Enter 'recap' for instruction summary,
~ Enter 'list' for printing list again,

~ to add a topic at last enter 'a:' and new topic name, like 'a: this is the new topic',
~ to add a topic at specific index enter 'a' with index and new topic name, like 'a3: this is the new topic',
~ to add many topics at any or last you can combine things like: '[a: this is new last topic],[a3: this topic will added at index 3],[a: this topic will be last]'

~ to modify the sequence of the list enter old_index + '->' + new_index, like '2->3'
    NOTE: be very specific about the syntax,
          this will move up/down the remaining topics accordingly, like will move other topics up if topic moved down, or vive-versa
~ to modify index (interchange the indexes), enter old_index + '<->' + new_index, like '2<->3'

~ to modify a topic, enter 'm' with index and modified topic, like 'm1: new topics title', make sure you don't use ':', you can use '()' instead,
~ to modify many topics you can enter like '[m1: new title for index 1],[m4: new title for index 4],[m6: new title for index 6]'

~ to remove any topic, enter 'r' with index like 'r1' to remove first topic
~ to remove many topics enter topics index with 'r' like 'r1,r4,r7'
    """

    instruction_recap=""" ~~~~ INSTRUCTIONS RECAP ~~~~
~ 'ok'
~ 'instruct'
~ 'recap'
~ 'list'
~ ADD:
    1. a: new topic at last
    2. a2: new topic at a index
    3. [a: new topic at last],[a2: new topic at a index],[a: new topic at last]
~ REMOVE:
    1. r1
    2. r2,r5,r6
~ MODIFY:
    1. m1: modified topic at index 1
    2. [m3: modified topic at index 3],[m5: modified topic at index 5],[m8: modified topic at index 8]
~ SEQUENCE:
    1. 2->4
    2. 2<->4
    """

    def __init__(self, topics):
        self.topicsByAI = topics

    def validateTopics(self):
        if( type(self.topicsByAI) is not list or self.topicsByAI==[]):
            raise Exception("invalid input")

        self.__printList()
        print(self.instructions)
        self.__getAndProcessInput()

    def __getAndProcessInput(self):
        flag = True
        text = "No Change made"
        while flag:
            key = input("Enter your input: ").strip()

            # if the list is perfect
            if(key == "ok"):
                flag = False
                text = "generating notes"
            # if user wants instructions again
            elif(key == "instruct"):
                print(self.instructions)
                text = ""
            # if wants instruction recap
            elif(key == 'recap'):
                print(self.instruction_recap)
                text = ""
            #printing list again
            elif(key == "list"):
                self.__printList()
            # if addition
            elif(key[0]=='a'):
                self.__manageAdd(key)
                text = "Added topic to list"
            # if multiple addition
            elif(re.fullmatch(r'^\[(a\d+: [^\]]+)\](,\[(a\d+: [^\]]+)\])*$', key)):
                self.__manageMultipleAdd(key)
                text = "Added topics to list"
            # if removal
            elif(key[0]=='r'):
                self.__manageRemove(key)
                text = "Removed topic from list"
            # if sequence change
            elif(key[0].isnumeric and re.match(r"^\d+(->|<->)\d+$", key)):
                self.__manageSequence(key)
                text = "Changed sequence of the list"
            # modify topics
            elif(key[0]=='m'):
                self.__manageModify(key)
                text = "Modified topic of the list"
            # manage multiple modify
            elif(re.fullmatch(r'^\[(m\d+: [^\]]+)\](,\[(m\d+: [^\]]+)\])*$', key)):
                self.__manageMultipleModify(key)
                text = "Modified topics of the list"
            # if none of it matches
            else:
                print("Invalid input")

            # reprinting list for verfication
            if(text!=""):
                self.__printList(text=text)

    def __manageAdd(self, key):
        key = str(key)

        # add at first
        if(key[0:2]=="a:"):
            topic = key[2:]
            self.topicsByAI.append(topic.strip())
        # add at index
        elif (key[1].isnumeric):
            keys = key.split(":")
            if(not keys[0][1:].isnumeric()):
                print("invalid format for ",key," in part ", keys)
            index = int(keys[0][1:])-1
            topic = keys[1].strip()
            self.topicsByAI.insert(index, topic)
        else:
            print("Invalid format, something went wrong, your key: ",key)

    # manage multiple adds
    def __manageMultipleAdd(self, key):
        key = str(key)
        topicsToAdd = key.split(key,"],[")

        # handle each topic
        for i in topicsToAdd:
            i = i.replace("[","").replace("]","").strip()
            self.__manageAdd(i)

    # manage single modify
    def __manageModify(self,key):
        key = str(key)

        if (key[0]=="m" and key[1].isnumeric()):
            keys = key.split(":")
            index = int(keys[0][1:])-1
            topic = keys[1].strip()
            self.topicsByAI[index] = topic
        else:
            print("Invalid format, something went wrong, your key: ",key)

    # manage multiple modifications
    def __manageMultipleModify(self, key):
        key = str(key)
        topicsToAdd = key.split(key,"],[")

        # handle each topic
        for i in topicsToAdd:
            i = i.replace("[","").replace("]","").strip()
            self.__manageModify(i)

    # manage removals
    def __manageRemove(self, key):
        key = str(key)
        indexes = key.split(",")
        tempList = self.topicsByAI
        # loping and removing
        for i in indexes:
            if(i[0]=="r" and i[1:].isnumeric()):
                index = int(i[1:])-1
                if(index>=len(self.topicsByAI)):
                    print("invalid range")
                    return
                tempList.remove(self.topicsByAI[index])
            else:
                print(f"invalid format in {key}, {i}")
        self.topicsByAI = tempList

    # manage sequence
    def __manageSequence(self, key):
        key = str(key).strip()

        if(key[0].isnumeric() and key[-1].isnumeric()):
            index1 = key[0]
            index2 = key[-1]

            # if interchange
            if(len(key)==4 and key.find("<->")!= -1):
                value1 = key[index1]
                key[index1] = key[index2]
                key[index2] = value1
            # interchange the values
            elif(len(key)==3 and key.find("->")!=-1):
                self.topicsByAI = moveElement(self.topicsByAI, index1, index2)
        else:
            print("Invalid format, you key was: ", key)

    # print topic list
    def __printList(self, text= "These topics covered will be: "):

        print(text)
        for i in self.topicsByAI:
            print(f"{self.topicsByAI.index(i)+1}) {i}")

def format_text(text):

    # Escape special HTML characters
    text = text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')

    # Bold for "quoted text"
    text = re.sub(r'"(.*?)"', r'<b>\1</b>', text)

    # Gray color for `code-like text`
    text = re.sub(r'`(.*?)`', r'<font color="#666666">\1</font>', text)

    # Handle bullet points starting with -
    lines = text.split('\n')
    formatted_lines = []
    for line in lines:
        if line.strip().startswith("-"):
            bullet = "&bull;"  # Unicode bullet
            content = line.strip()[1:].strip()
            formatted_line = f"&nbsp;&nbsp;&nbsp;&nbsp;{bullet} {content}"
        else:
            formatted_line = line
        formatted_lines.append(formatted_line)

    return "<br/>".join(formatted_lines)


def generatePDF(topics, answers, title):
    title = str(title)
    pdf_file = f"{title.lower().replace(' ', '_')}_notes.pdf"
    doc = SimpleDocTemplate(pdf_file, pagesize=A4,
                            rightMargin=40, leftMargin=40,
                            topMargin=60, bottomMargin=40)

    styles = getSampleStyleSheet()
    story = []

    # Title
    story.append(Paragraph(f"<font size=22 color='#003399'><b>Notes on: {title}</b></font>", styles['Title']))
    story.append(Spacer(1, 0.3 * inch))

    for i, topic in enumerate(topics):
        # Subtopic title
        story.append(Paragraph(f"<font size=16 color='#FF5733'><b>{i+1}.) {topic}</b></font>", styles['Heading2']))
        story.append(Spacer(1, 0.1 * inch))

        # Format and add content
        formatted_answer = format_text(answers[i])
        story.append(Paragraph(f"<font size=11>{formatted_answer}</font>", styles['BodyText']))
        story.append(Spacer(1, 0.3 * inch))

    doc.build(story)
    print(f"PDF generated: {pdf_file}")


# Utility to generate topic-wise questions PDF

def generate_topicwise_questions_pdf(title, questions, answers, topic):
    from uuid import uuid4
    styles = getSampleStyleSheet()

    filename = f"{title.lower().replace(' ', '_')}_topicwise_questions.pdf"
    temp_filename = f"temp_{uuid4().hex}.pdf"  # Temporary file to hold new content

    story = []

    # Add topic heading
    story.append(Paragraph(f"<font size=16 color='#003399'><b>Topic: {topic}</b></font>", styles["Heading2"]))
    story.append(Spacer(1, 0.2 * inch))

    for q in questions:
        story.append(Paragraph(f"<font size=11>{q.strip()}</font>", styles["BodyText"]))
        story.append(Spacer(1, 0.2 * inch))
    story.append(Spacer(1, 0.3 * inch))
    story.append(Paragraph(f"<font size=11>Answers</font>", styles["BodyText"]))
    story.append(Spacer(1, 0.2 * inch))
    for a in answers:
        q = a["q_no"]
        ans = a["answer"]
        story.append(Paragraph(f"<font size=11>{q}. {ans}</font>", styles["BodyText"]))
        story.append(Spacer(1, 0.2 * inch))

    # Generate new content into a temp PDF
    doc = SimpleDocTemplate(temp_filename, pagesize=A4, rightMargin=40, leftMargin=40, topMargin=60, bottomMargin=40)
    doc.build(story)

    if os.path.exists(filename):
        # Merge existing file with new temp content
        merger = PdfMerger()
        merger.append(filename)         # Old content
        merger.append(temp_filename)    # New content
        merger.write(filename)          # Overwrite with merged content
        merger.close()
        os.remove(temp_filename)        # Clean up temp file
    else:
        # If file doesn't exist, just rename the temp file as final
        os.rename(temp_filename, filename)

    return filename


# Utility to generate final question paper with optional answer key
def generate_final_questionpaper_pdf(title, final_paper, answer_key=None):
    filename = f"{title.lower().replace(' ', '_')}_final_question_paper.pdf"
    doc = SimpleDocTemplate(filename, pagesize=A4, rightMargin=40, leftMargin=40, topMargin=60, bottomMargin=40)
    styles = getSampleStyleSheet()
    story = []

    story.append(Paragraph("<b>FINAL QUESTION PAPER</b>", styles['Title']))
    story.append(Spacer(1, 0.3 * inch))

    for i, q in enumerate(final_paper):
        story.append(Paragraph(q, styles["BodyText"]))
        story.append(Spacer(1, 0.2 * inch))

    if answer_key:
        story.append(PageBreak())
        story.append(Paragraph("<b>ANSWER KEY</b>", styles['Title']))
        story.append(Spacer(1, 0.3 * inch))
        for ans in answer_key:
            story.append(Paragraph(ans, styles["BodyText"]))
            story.append(Spacer(1, 0.1 * inch))

    doc.build(story)
    return filename

def callModel(prompt, model="gemini"):
    model = model.lower()
    return connectGemini2Flash(prompt)

def convertIntoArray(data):
    lines = data.split('\n')
    items = []
    for line in lines:
        line = line.strip()
        if line.startswith("-"):
            item = line[1:].strip()
            if item:
                items.append(item)
    return items

def getTopics(title, subject, maturity, preDefineTopics, complexity, extraNotes ):
    if recommendTopics:
        prompt = f"""
You are an expert academic assistant.

Given the main topic: "{title}",
Subject: "{subject}",
Target learner level: "{maturity}",
complexity of the content: "{complexity}"
"{extraNotes}"
List all the essential subtopics required to fully understand this topic at a basic to medium level of depth.

Please:
- List topics in bullet points starting with '-'
- Keep them short (a few words), no extra explanation
"""

        if recommendTopics and preDefineTopics !="":
            prompt += f"""
The user already has a predefined list of topics:
{preDefineTopics}

Please:
- Review the predefined topics
- Suggest improvements or additional recommended topics
- Then print a clean, updated list starting with '-'
"""

        prompt += "\nTopics:\n"


        response = callModel(prompt, model="gemini")
        tempTopics = convertIntoArray(response)
        topics = ValidateTopics(tempTopics)
        topics.validateTopics()
        return topics.topicsByAI
    else:
        preDefineTopics = str(preDefineTopics)
        return preDefineTopics.replace("\n","").split(",,")

def getExplanation(topic, length, subject, maturity, complexity, extraNotes, title, topicsAlreadyCovered, otherTopicsLeft, model = "local"):
    topicsAlreadyCovered = list(topicsAlreadyCovered)
    otherTopicsLeft = list(otherTopicsLeft)

    prompt = f"""
Explain the topic: "{topic}" in a clear, structured, and beginner-friendly way.
approx length of the explanations should be {length}
Subject: "{subject}",
The main parent topic is: "{title}", write content relating to this
Target learner level: "{maturity}",
complexity of the content: "{complexity}"
and the topics already covered are : {",".join(topicsAlreadyCovered)}, so don't include these topics (you can short recap things if they are referenced for current topic)
and the topics for future are : {",".join(otherTopicsLeft)}, so don't include content of these (you can provide a context to further reference if needed)

"{extraNotes}"
- Break it down into key subtopics or components.
- For each subtopic, provide a brief explanation and, where useful, an example or analogy.
- Use bullet points or headings.
- Avoid repeating instructions or filler text.

Start directly:
"""
    if(model=="gemini"):
        prompt += "make it a plain text only , no formatting, no #, *, for formatting for anything, bulleting you can use numbers or '-', nothing else... "
    response = callModel(prompt, model=model)

    if response is None:
        raise Exception("Invalid response from model")

    answer = response
    print(f"Explanation for {topic}:\n{answer}\n")
    return answer

def makeQuestions(topic, chapter, subject, otherTopics, complexity, maturity, addMCQs = True, addTruFalse = False, addOneWord = False, addFIBs = False, questions = 10, lastQuestionNumber = 0, model = "local"):
    startNum = lastQuestionNumber + 1
    topicList = ", ".join(otherTopics)

    prompt = f"""
You are an experienced educator and professional exam paper setter.

Generate {questions} high-quality, diverse, and original exam-style questions for the topic: "{topic}" in the chapter: "{chapter}" under the subject: "{subject}".

Other related topics to consider for depth and relevance: {topicList}

Guidelines:
1. Difficulty: {complexity.capitalize()}
2. Student Maturity Level: {maturity}
3. Start numbering from question number {startNum}
4. Use plain text only - no markdown, no *, #, or formatting symbols.
5. Follow standard exam paper formatting:
   - Numbered questions.
   - Proper punctuation and spacing.
   - Leave a blank line between questions.
   - Do NOT include answers with the questions.

Structure:
{ 'Section: Multiple Choice Questions\n- Provide 4 options (a)-(d) for each MCQ.' if addMCQs else '' }
{ 'Section: True or False\n- Provide clear factual statements.' if addTruFalse else '' }
{ 'Section: One Word Answer Questions\n- Each question must have a single-word answer.' if addOneWord else '' }
{ 'Section: Fill in the Blanks\n- Use grammatically correct sentences with blanks.' if addFIBs else '' }
Note: don't include any other format / structure other than these...

After all questions, write an "Answer Key" section formatted like this:

Answer Key:
1. (b)
2. True
3. Inertia
...

Only output the questions followed by the answer key. No extra explanations.
"""

    if model == "gemini":
        prompt += "\nEnsure this is all plain text. No formatting symbols like *, #, etc."

    response = callModel(prompt)

    if response is None:
        raise Exception("Invalid response from model")

    raw_output = response.strip()

    # Split into questions and answers
    if "Answer Key:" in raw_output:
        question_part, answer_part = raw_output.split("Answer Key:", 1)
    else:
        raise Exception("Answer key not found in the output")

    # Extract each question line (ignore empty lines)
    question_lines = [line.strip() for line in question_part.strip().split("\n") if line.strip()]

    # Extract answers from answer part
    # Supports formats like "1. (b)" or "2. True" or "3. Gravity"
    answer_lines = [line.strip() for line in answer_part.strip().split("\n") if re.match(r"^\d+\.\s", line.strip())]

    # Parse into clean lists
    questions = question_lines
    answers = []
    for line in answer_lines:
        match = re.match(r"^(\d+)\.\s+(.*)", line)
        if match:
            q_num = int(match.group(1))
            ans = match.group(2).strip()
            answers.append({"q_no": q_num, "answer": ans})

    return {
        "questions": questions,
        "answers": answers
    }

# def get_image_links(query, limit=imagesLimit):
#     """
#     Returns a list of image URLs for the given search query.

#     Args:
#         query (str): Search term (e.g., "8085 microprocessor")
#         limit (int): Number of image URLs to fetch

#     Returns:
#         list[str]: List of direct image URLs
#     """
#     urls = []
#     with DDGS() as ddgs:
#         for r in ddgs.images(query, max_results=limit):
#             urls.append(r["image"])
#     return urls

def get_google_images(query, api_key, cx, limit=3):
    service = build("customsearch", "v1", developerKey=api_key)
    res = service.cse().list(
        q=query,
        cx=cx,
        searchType='image',
        num=limit
    ).execute()
    
    image_urls = []
    for item in res.get("items", []):
        image_urls.append(item["link"])
    return image_urls

def google_search(query, api_key, cx):
    """
    Perform a Google Custom Search and return top 3 results as a list of dictionaries.

    Each dictionary contains:
        - title
        - link
        - snippet
    """
    service = build("customsearch", "v1", developerKey=api_key)
    res = service.cse().list(q=query, cx=cx, num=search_result_count).execute()

    results = []
    for item in res.get("items", []):
        results.append({
            "title": item.get("title"),
            "link": item.get("link"),
            "snippet": item.get("snippet")
        })

    return results

# ========================= üå∏ Elegant Student Notes Page Generator üå∏ ========================= #
# This cell builds a modern, cute HTML notes page for your chapter with light/dark mode,
# topic sections, related images, Google search results, and a search box.

import datetime
from IPython.display import HTML, display

# ========================== üé® Style Configuration ========================== #
style_config = {
    "light": {
        "primary_color": "#70B2B2",
        "secondary_color": "#9ECFD4",
        "background_color": "#016B61",
        "text_color": "#ECF4E8",
        "card_color": "#B7B89F"
    },
    "dark": {
        "primary_color": "#90CAF9",
        "secondary_color": "#9ECFD4",
        "background_color": "#121212",
        "text_color": "#EDEDED",
        "card_color": "#1E1E1E"
    },
    "font_family": "Poppins",
    "font_url": "https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap",
    "border_radius": "12px",
    "box_shadow": "0 4px 12px rgba(0, 0, 0, 0.1)"
}

search_box = """
<script async src="https://cse.google.com/cse.js?cx=a77c6c63871e34bf3"></script>
<div class="gcse-search"></div>
"""

# ========================== üß† HTML Generator Function ========================== #
def generate_notes_page(chapter_name, topics, answers, all_questions, api_key, cx, images_limit=3):
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M")
    filename = f"{chapter_name.replace(' ', '_')}_{timestamp}.html"

    # Load font link
    font_link = f'<link href="{style_config["font_url"]}" rel="stylesheet">'

    # Base CSS styles with light and dark themes
    css = f"""
    {font_link}
    <style>
    body {{
        font-family: '{style_config["font_family"]}', sans-serif;
        background-color: {style_config["light"]["background_color"]};
        color: {style_config["light"]["text_color"]};
        margin: 0; padding: 0;
        transition: background 0.3s, color 0.3s;
    }}
    header {{
        background: linear-gradient(90deg, {style_config["light"]["primary_color"]}, {style_config["light"]["secondary_color"]});
        padding: 2rem;
        text-align: center;
        font-size: 2.2rem;
        font-weight: 600;
        border-radius: 0 0 20px 20px;
        box-shadow: {style_config["box_shadow"]};
    }}
    .topic {{
        background-color: {style_config["light"]["card_color"]};
        border-radius: {style_config["border_radius"]};
        box-shadow: {style_config["box_shadow"]};
        padding: 1.2rem;
        margin: 1.5rem;
        transition: background 0.3s;
    }}
    .topic h2 {{
        color: {style_config["light"]["primary_color"]};
        font-size: 1.5rem;
    }}
    .images {{
        display: flex; gap: 10px; flex-wrap: wrap;
    }}
    .images img {{
        border-radius: 10px;
        width: 30%;
        object-fit: cover;
    }}
    .google-results {{
        margin-top: 10px;
    }}
    .google-result {{
        padding: 0.8rem;
        border-radius: 8px;
        background: {style_config["light"]["secondary_color"]};
        margin-bottom: 0.5rem;
    }}
    .all-questions {{
        margin: 2rem;
        padding: 1rem;
        background: {style_config["light"]["card_color"]};
        border-radius: {style_config["border_radius"]};
    }}
    footer {{
        text-align: center;
        padding: 2rem;
        font-size: 1rem;
    }}
    /* üåó Dark Mode Styles */
    body.dark {{
        background-color: {style_config["dark"]["background_color"]};
        color: {style_config["dark"]["text_color"]};
    }}
    body.dark header {{
        background: linear-gradient(90deg, {style_config["dark"]["primary_color"]}, {style_config["dark"]["secondary_color"]});
    }}
    body.dark .topic, body.dark .all-questions {{
        background-color: {style_config["dark"]["card_color"]};
    }}
    body.dark .google-result {{
        background: {style_config["dark"]["secondary_color"]};
    }}
    /* üåô Dark Mode Toggle Button */
    #mode-toggle {{
        position: fixed;
        top: 15px; right: 15px;
        background: {style_config["light"]["primary_color"]};
        border: none;
        color: white;
        border-radius: 50%;
        width: 40px; height: 40px;
        font-size: 20px;
        cursor: pointer;
        box-shadow: {style_config["box_shadow"]};
    }}
    body.dark #mode-toggle {{
        background: {style_config["dark"]["primary_color"]};
    }}
    </style>
    """

    # JavaScript for Dark Mode
    js_toggle = """
    <script>
    function toggleMode() {
        document.body.classList.toggle('dark');
        const icon = document.getElementById('mode-toggle');
        icon.textContent = document.body.classList.contains('dark') ? '‚òÄÔ∏è' : 'üåô';
    }
    </script>
    """

    # Header
    html = f"""
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Notes - {chapter_name}</title>
        {css}
    </head>
    <body>
    <button id="mode-toggle" onclick="toggleMode()">üåô</button>
    <header>üìò {chapter_name} ‚ú®</header>
    """

    # Generate Topics
    for topic, answer in zip(topics, answers):
        html += f'<div class="topic"><h2>üí° {topic}</h2><div style="white-space: pre-wrap;">{answer}</div>'

        # Related Images
        images = get_google_images(f"{topic} ({chapter_name})", limit=images_limit, api_key= google_search_api_key, cx=google_search_cx)
        if images:
            html += '<div class="images">'
            for img in images:
                html += f'<img src="{img}" alt="{topic} image">'
            html += '</div>'

        # Google Search Results
        results = google_search(f"{topic} ({chapter_name})", api_key, cx)
        if results:
            html += '<div class="google-results"><h4>üîó Related Resources:</h4>'
            for res in results:
                html += f"""
                <div class="google-result">
                    <a href="{res['link']}" target="_blank"><strong>{res['title']}</strong></a><br>
                    <small>{res['snippet']}</small>
                </div>
                """
            html += '</div>'
        html += '</div>'

    # All Questions Section
    html += '<div class="all-questions"><h2>üñäÔ∏è All Questions</h2>'
    for q in all_questions:
        html += f"<p>{q}</p>"
    html += "</div>"

    # Search Box + Footer
    html += f"""
    <footer>
        <h3>üîç Search More</h3>
        {search_box}
        <p>Generated on {timestamp}</p>
    </footer>
    {js_toggle}
    </body></html>
    """

    # Save to HTML
    with open(filename, "w", encoding="utf-8") as f:
        f.write(html)

    # Create Download Button in Colab
    display(HTML(f"""
    <div style='margin:20px;text-align:center;'>
        <a href='{filename}' download='{filename}'
           style='background:{style_config["light"]["primary_color"]};color:white;padding:10px 20px;
                  border-radius:10px;text-decoration:none;font-weight:600;'>
           üíæ Download {filename}
        </a>
    </div>
    """))

    print(f"Notes page saved as {filename}")

import base64
from IPython.display import HTML, display

def generate_flash_cards(
    subject,
    title,
    topics,
    maturity,
    extraNotes,
    complexity,
    num_cards=15,
    card_type="question",
    theme="light",
    custom_prompt=None
):
    """
    Generate interactive flashcards with collapsible topic sections,
    light/dark mode, shuffle, and progress tracking.
    """

    # -------------------------------
    # 1. STYLE CONFIG
    # -------------------------------
    style = style_config
    colors = style.get(theme, style["light"])

    # -------------------------------
    # 2. GENERATE FLASHCARDS PER TOPIC
    # -------------------------------
    all_flashcards_html = ""
    total_cards = 0

    for topic in topics:
        # Build prompt per topic
        if card_type == "question":
            prompt = f"""
            Generate {num_cards} flashcards for the subject "{subject}"
            covering topic "{topic}" for a {maturity}.

            Each card:
            - Front: Question/concept
            - Back: Answer/explanation with examples

            Format:
            ---Card---
            Front: <Question>
            Back: <Answer>
            """
        elif card_type == "revision":
            prompt = f"""
            Generate {num_cards} revision flashcards for "{topic}" in {subject}.
            Each card:
            - Front: Topic/keyword
            - Back: Explanation/connection

            Format:
            ---Card---
            Front: <Topic>
            Back: <Explanation>
            """
        elif card_type == "custom" and custom_prompt:
            prompt = f"{custom_prompt}\nSubject: {subject}\nTopic: {topic}\nTitle: {title}\nMaturity: {maturity}\nNotes: {extraNotes}\nComplexity: {complexity}"
        else:
            raise ValueError("Invalid card_type or missing custom_prompt for 'custom' mode.")

        # Call Gemini API (replace with your function)
        flashcards_text = connectGemini2Flash(prompt)
        flashcards_text = re.sub(r"\*\*(.*?)\*\*", r"<b>\1</b>", flashcards_text)
        flashcards_text = re.sub(r"\*(.*?)\*", r"<i>\1</i>", flashcards_text)
        flashcards_text.replace("*","")
        # Parse cards
        cards = []
        for block in flashcards_text.split('---Card---'):
            if 'Front:' in block and 'Back:' in block:
                front = block.split('Front:')[1].split('Back:')[0].strip()
                back = block.split('Back:')[1].strip()
                cards.append({"front": front, "back": back})
        flashcards = cards[:num_cards]
        total_cards += len(flashcards)

        # Build HTML for this topic
        topic_html_cards = ""
        for idx, card in enumerate(flashcards, start=1):
            topic_html_cards += f"""
            <div class="flashcard" onclick="flipCard(this)">
                <div class="flashcard-inner">
                    <div class="front">
                        <h3>Card {idx}</h3>
                        <p>{card["front"]}</p>
                    </div>
                    <div class="back">
                        <h3>Answer</h3>
                        <p>{card["back"]}</p>
                    </div>
                </div>
            </div>
            """

        # Collapsible section per topic
        all_flashcards_html += f"""
        <button class="accordion">{topic}</button>
        <div class="panel">
            {topic_html_cards}
        </div>
        """

    # -------------------------------
    # 3. HTML TEMPLATE
    # -------------------------------
    html_template = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>{subject} - {title}</title>
        <link href="{style['font_url']}" rel="stylesheet">
        <style>
            :root {{
                --primary-color: {colors["primary_color"]};
                --secondary-color: {colors["secondary_color"]};
                --bg-color: {colors["background_color"]};
                --text-color: {colors["text_color"]};
                --card-color: {colors["card_color"]};
                --border-radius: {style["border_radius"]};
                --box-shadow: {style["box_shadow"]};
            }}
            body {{
                font-family: '{style['font_family']}', sans-serif;
                background: var(--bg-color);
                color: var(--text-color);
                text-align: center;
                margin: 0;
                padding: 0 10px;
                transition: background 0.5s ease, color 0.5s ease;
            }}
            h1 {{ margin-top: 25px; }}

            button {{
                background: var(--primary-color);
                color: var(--text-color);
                border: none;
                padding: 10px 16px;
                border-radius: var(--border-radius);
                cursor: pointer;
                font-size: 14px;
                margin: 4px;
                box-shadow: var(--box-shadow);
                transition: transform 0.2s;
            }}
            button:hover {{ transform: scale(1.05); background: var(--secondary-color); }}

            .flashcard {{
                width: 90%;
                max-width: 340px;
                min-height: 220px;
                margin: 20px auto;
                perspective: 1000px;
                cursor: pointer;
                border-radius: var(--border-radius);
                box-shadow: var(--box-shadow);
                position: relative;
            }}

            .flashcard-inner {{
                position: relative;
                width: 100%;
                height: 100%;
                transition: transform 0.6s;
                transform-style: preserve-3d;
            }}

            .flashcard.flipped .flashcard-inner {{
                transform: rotateY(180deg);
            }}

            .flashcard .front, .flashcard .back {{
                position: absolute;
                width: 100%;
                height: 220px;  /* fixed height */
                backface-visibility: hidden;
                border-radius: var(--border-radius);
                padding: 20px;
                box-sizing: border-box;
                display: flex;
                flex-direction: column;
                justify-content: flex-start; /* top-align content */
                align-items: flex-start;     /* left-align content */
                background: var(--card-color);
                color: var(--text-color);
                overflow-y: auto;  /* scroll if content exceeds height */
            }}

            .flashcard .back {{
                transform: rotateY(180deg);
            }}


            /* Accordion */
            .accordion {{
                background-color: var(--primary-color);
                color: var(--text-color);
                cursor: pointer;
                padding: 10px;
                width: 90%;
                max-width: 360px;
                border: none;
                text-align: left;
                outline: none;
                font-size: 16px;
                transition: background-color 0.3s;
                margin: 10px auto;
            }}
            .accordion.active, .accordion:hover {{ background-color: var(--secondary-color); }}
            .panel {{
                padding: 0 10px;
                display: none;
                overflow: hidden;
                background-color: var(--bg-color);
            }}

            #progress {{ margin-top: 10px; font-weight: bold; }}
        </style>
    </head>

    <body>
        <h1>{subject} - {title}</h1>
        <div class="controls">
            <button onclick="toggleTheme()">Toggle Theme</button>
            <button onclick="shuffleCards()">Shuffle Cards</button>
            <div id="progress">You've reviewed 0 / {total_cards} cards</div>
        </div>

        <div id="cardContainer">{all_flashcards_html}</div>

        <script>
            let flippedCount = 0;
            let totalCards = {total_cards};
            let darkMode = {str(theme=="dark").lower()};

            function flipCard(card) {{
                card.classList.toggle('flipped');
                flippedCount = document.querySelectorAll('.flipped').length;
                document.getElementById('progress').innerText = `You've reviewed ${'{'}flippedCount{'}'} / ${'{'}totalCards{'}'} cards`;
            }}

            function shuffleCards() {{
                const panels = document.querySelectorAll('.panel');
                panels.forEach(panel => {{
                    const cards = Array.from(panel.children);
                    for (let i = cards.length - 1; i > 0; i--) {{
                        const j = Math.floor(Math.random() * (i + 1));
                        [cards[i], cards[j]] = [cards[j], cards[i]];
                    }}
                    panel.innerHTML = '';
                    cards.forEach(c => panel.appendChild(c));
                }});
            }}

            function toggleTheme() {{
                darkMode = !darkMode;
                const root = document.documentElement;
                if (darkMode) {{
                    root.style.setProperty('--primary-color', '{style["dark"]["primary_color"]}');
                    root.style.setProperty('--secondary-color', '{style["dark"]["secondary_color"]}');
                    root.style.setProperty('--bg-color', '{style["dark"]["background_color"]}');
                    root.style.setProperty('--text-color', '{style["dark"]["text_color"]}');
                    root.style.setProperty('--card-color', '{style["dark"]["card_color"]}');
                }} else {{
                    root.style.setProperty('--primary-color', '{style["light"]["primary_color"]}');
                    root.style.setProperty('--secondary-color', '{style["light"]["secondary_color"]}');
                    root.style.setProperty('--bg-color', '{style["light"]["background_color"]}');
                    root.style.setProperty('--text-color', '{style["light"]["text_color"]}');
                    root.style.setProperty('--card-color', '{style["light"]["card_color"]}');
                }}
            }}

            // Accordion logic
            const acc = document.getElementsByClassName("accordion");
            for (let i = 0; i < acc.length; i++) {{
                acc[i].addEventListener("click", function() {{
                    this.classList.toggle("active");
                    const panel = this.nextElementSibling;
                    if (panel.style.display === "block") {{
                        panel.style.display = "none";
                    }} else {{
                        panel.style.display = "block";
                    }}
                }});
            }}
        </script>
    </body>
    </html>
    """

    # -------------------------------
    # 4. SAVE HTML + DOWNLOAD BUTTON
    # -------------------------------
    filename = f"{title.lower().replace(' ','_')}_flashcards.html"
    with open(filename, "w", encoding="utf-8") as f:
        f.write(html_template)

    b64_html = base64.b64encode(html_template.encode()).decode()
    download_html = f'<a download="{filename}" href="data:text/html;base64,{b64_html}" target="_blank"><button style="padding:10px 20px; font-size:16px;">‚¨áÔ∏è Download {title} Flashcards</button></a>'

    display(HTML(download_html))
    print(f"‚úÖ Flashcards generated successfully! Saved as '{filename}'.")
    return html_template




if __name__ == "__main__":

    if(not isDebug):
        title = input("For what topic do you want your notes?: ")
        subject = input("Subject: ").strip()
        length = input("Length of the subtopics explanations (eg. 100 lines, 200 words): ").strip()
        maturity = input("Maturity of notes (enter human age, or grade or other) (eg: 12 years old, 12th grade med student, PHD student): ").strip()
        complexity = input("How much complexity do you want (basic, simple. medium, in depth, complex): ")
        extraNotes = input("any extra notes?: ")
        preDefineTopics = input("Do you have any predefined list of topics? if no then press 'Enter' or 'Return' yes then enter them separated with commas(,,), (topic1,, new topic 2): ").strip()
        wantGemini = True if int(input("do you want gemini? (1/0): ")) == 1 else False
    topics = getTopics(title, subject, maturity, preDefineTopics, complexity, extraNotes)

    with open(f"{title.lower().replace(" ","_")}.txt", "a") as f:
            f.write("-------------------- TOPICS -----------------\n")

            for item in topics:
                f.write(str(topics.index(item))+".) "+item)
                f.write("\n")

    answers = []
    final_paper = []
    answer_key = []
    questions_filename = f"{title.lower().replace(' ', '_')}_questions.txt"
    all_questions = []

    proceed = (input(f"Topic to start with is: {topics[startIndex::][0]} (1/0): ").strip()) == "1"
    if not proceed :
        sys.exit()

    for i, topic in enumerate(topics[startIndex::]):

        if getNotes:
            answer = getExplanation(topic, length, subject, maturity, complexity, extraNotes, title, topics[:i], topics[i+1:], model= "gemini" if wantGemini else "local")
            answers.append(answer)

            # Save as .txt
            with open(f"{title.lower().replace(' ', '_')}.txt", "a") as f:
                f.write(f"{i+1}.) {topic}\n")
                f.write(answer)
                f.write("\n\n\n")

            # Only pass topics/answers up to current index
            generatePDF(topics[startIndex:i+1], answers[:i+1], title+f"_from_{startIndex}")

        if getQuestions:
            questions_filename = f"{title.lower().replace(' ', '_')}_questions.txt"
            all_answers = []

            with open(questions_filename, "a") as f:
                print(f"Generating questions for topic: {topic}")

                result = makeQuestions(
                    topic=topic,
                    chapter=title,
                    subject=subject,
                    otherTopics=topics[:i] + topics[i+1:],
                    complexity=complexity,
                    maturity=maturity,
                    addMCQs=True,
                    addTruFalse=False,
                    addOneWord=False,
                    addFIBs=False,
                    questions=15,
                    lastQuestionNumber=len(all_questions),
                    model="gemini" if wantGemini else "local"
                )

                f.write(f"Topic: {topic}\n\n")
                for q in result["questions"]:
                    f.write(q + "\n")
                f.write("\n\n")

                # Parse and store questions
                question_block = []
                current_q_number = None

                for q_text in result["questions"]:
                    q_text = q_text.strip()

                    # Start of a new question
                    match = re.match(r"^(\d+)\.\s+(.*)", q_text)
                    if match:
                        if question_block and current_q_number is not None:
                            # Store the previous full question block
                            full_question_text = "\n".join(question_block)
                            answer_obj = next((a for a in result["answers"] if a["q_no"] == current_q_number), None)
                            answer_text = answer_obj["answer"] if answer_obj else "N/A"
                            all_questions.append({
                                "original_q_no": current_q_number,
                                "text": full_question_text,
                                "answer": answer_text,
                                "topic": topic
                            })

                        # Start a new question block
                        current_q_number = int(match.group(1))
                        question_block = [q_text]

                    else:
                        # Continuation of options or explanation
                        if current_q_number is not None:
                            question_block.append(q_text)

                # Save the last question block
                if question_block and current_q_number is not None:
                    full_question_text = "\n".join(question_block)
                    answer_obj = next((a for a in result["answers"] if a["q_no"] == current_q_number), None)
                    answer_text = answer_obj["answer"] if answer_obj else "N/A"
                    all_questions.append({
                        "original_q_no": current_q_number,
                        "text": full_question_text,
                        "answer": answer_text,
                        "topic": topic
                    })

                print("generating topic vise question paper")
                # generating topic vise PDF
                ans = generate_topicwise_questions_pdf(title, result["questions"], result["answers"], topic)

    if getQuestions:
        print("generating final question paper")
        # genPDF.generatePDF(topics, answers, title)
        random.shuffle(all_questions)
        final_paper = []
        answer_key = []

        for i, q in enumerate(all_questions):
            q_number = i + 1
            final_paper.append(f"{q_number}. {q['text']}")
            answer_key.append(f"{q_number}. {q['answer']}")

        # Save final paper
        final_filename = f"{title.lower().replace(' ', '_')}_final_paper.txt"
        with open(final_filename, "w") as f:
            f.write("FINAL QUESTION PAPER\n\n")
            for i, q in enumerate(all_questions):
                f.write(f"{i+1}. {q['text']}\n\n")   # Already includes options
            f.write("\nANSWER KEY\n\n")
            for i, a in enumerate(all_questions):
                f.write(f"{i+1}. {a['answer']}\n")

        # save final paper pdf
        ans = generate_final_questionpaper_pdf(title=title, final_paper=final_paper, answer_key=answer_key)
    if addImages:
        generate_notes_page(title, topics, answers, all_questions, google_search_api_key, google_search_cx, images_limit=3)
    if getFlashCards:
        generate_flash_cards(title=title, topics=topics, complexity=complexity, maturity=maturity, extraNotes=extraNotes, subject=subject, num_cards=10)